module;
#include "src/graphics/graphic_libs.h"
export module ray.graphics.rhi;

import glm;

export namespace ray::graphics {

#if RAY_GRAPHICS_ENABLE
class renderer {
public:
        renderer(GLFWwindow* basis_win);
        ~renderer();

        renderer(const renderer&) = delete;
        renderer& operator=(const renderer&) = delete;
        renderer(renderer&&) = default;
        renderer& operator=(renderer&&) = default;

        void draw_frame();

private:
        struct vertex {
                float pos[2];
                float uv[2];
        };

        bool create();
        void destroy();

        bool create_instance();
        void destroy_instance();

        bool create_surface();
        void destroy_surface();

        bool create_device();
        void destroy_device();

        bool create_swapchain();
        void destroy_swapchain();

        bool create_render_pass();
        void destroy_render_pass();

        bool create_pipeline();
        void destroy_pipeline();

        bool create_buffers();
        void destroy_buffers();

        bool create_commands();
        void destroy_commands();

        bool create_sync();
        void destroy_sync();

        void recreate_swapchain();

        VkShaderModule create_shader_module_from_file(const char* path);

        glm::u32 find_memory_type(glm::u32 typeBits, VkMemoryPropertyFlags props);
        bool create_buffer(VkDeviceSize size, VkBufferUsageFlags usage,
                VkMemoryPropertyFlags props, VkBuffer& outBuf, VkDeviceMemory& outMem);

private:
        GLFWwindow* win = nullptr;

        VkInstance instance = VK_NULL_HANDLE;
        VkSurfaceKHR surface = VK_NULL_HANDLE;

        VkPhysicalDevice physical = VK_NULL_HANDLE;
        VkDevice device = VK_NULL_HANDLE;

        glm::u32 gfx_family = UINT32_MAX;
        glm::u32 present_family = UINT32_MAX;

        VkQueue gfx_queue = VK_NULL_HANDLE;
        VkQueue present_queue = VK_NULL_HANDLE;

        VkSwapchainKHR swapchain = VK_NULL_HANDLE;
        VkFormat swapchain_format = VK_FORMAT_UNDEFINED;
        VkExtent2D swapchain_extent{};

        VkImage* swapchain_images = nullptr;
        glm::u32 swapchain_image_count = 0;
        VkImageView* swapchain_image_views = nullptr;

        VkRenderPass render_pass = VK_NULL_HANDLE;

        VkPipelineLayout pipeline_layout = VK_NULL_HANDLE;
        VkPipeline pipeline = VK_NULL_HANDLE;

        VkBuffer vbuf = VK_NULL_HANDLE;
        VkDeviceMemory vmem = VK_NULL_HANDLE;
        VkBuffer ibuf = VK_NULL_HANDLE;
        VkDeviceMemory imem = VK_NULL_HANDLE;

        VkCommandPool cmd_pool = VK_NULL_HANDLE;

        static constexpr glm::u32 k_frames_in_flight = 2;
        VkCommandBuffer cmd[k_frames_in_flight]{};

        VkSemaphore image_available[k_frames_in_flight]{};
        VkSemaphore render_finished[k_frames_in_flight]{};
        VkFence in_flight[k_frames_in_flight]{};
        glm::u8 frame_submitted[k_frames_in_flight] = {0};
        glm::u32 frame_index = 0;

        glm::u64 start_ticks = 0;
};

#endif
};